<head>
    <script>
        const key1 = null
        const key2 = null
        /**
         * Generate keypair for shared key derivation
         * @returns X25519 cryptoKey
         */
        async function generate_derivation_key() {
            // return await window.crypto.subtle.generateKey({name: "X15519"}, true, ["deriveKey", "deriveBits"]).catch(async () => {
            //     localStorage.setItem("usingECDH", true)
            return await window.crypto.subtle.generateKey({name: "ECDH", namedCurve: "P-384"}, true, ["deriveKey", "deriveBits"])
            // })
        }
        /**
         * Generate keypair for signature creation/verification
         * @returns Ed25519 cryptoKey
         */
        // async function generate_signing_key() {
        //     return await window.crypto.subtle.generateKey({name: "Ed25519"}, true, ["sign", "verify"])
        // }
        async function derive_symmetric_key(privateKey, publicKey) {
            // let algoName = "X25519"
            // if(localStorage.usingECDH == "true") algoName = "ECDH"
            return await window.crypto.subtle.deriveKey({name: "ECDH", namedCurve: "P-384", public: publicKey}, privateKey, {name: "AES-GCM", length: 256}, true, ["encrypt", "decrypt"])
        }
        function mksalt(iters, shift, salt_xor) {
            let salt = new Uint8Array(32)
            for(let iter=0; iter<iters; iter++)
                for(let i=0; i<31; i++) {
                    let rock_salt = ((Math.round(Math.sin((shift*32)+i+(iter*32))*0xffcdef12)^salt_xor) >> iter%35)
                    salt[i] ^= rock_salt & 0xff
                    salt[(i+rock_salt+(salt_xor & 0xfff))&31] ^= (rock_salt & 0xff00) >> 8
                }
            return salt
        }
        async function derive_new_key(keydf, nonce, salt_xor) {
            return await window.crypto.subtle.deriveKey({name: "PBKDF2", salt: mksalt(100, nonce, salt_xor), hash: "SHA-256", iterations: 10000}, keydf, {name: "AES-GCM", length: 256}, true, ["encrypt", "decrypt"])
        }
        async function new_pbkdf(sharedKey, nonce, salt_xor, HMACKey) {
            let keydata = new Uint8Array(await window.crypto.subtle.exportKey("raw", sharedKey))
            let salt = mksalt(10980, nonce, salt_xor)
            for(let i=0; i<32; i++) keydata[i] = salt[i]
            let newHBK = keydata
            if(typeof HMACKey != "undefined") newHBK = new Uint8Array(await window.crypto.subtle.sign({name: "HMAC"}, HMACKey, keydata))
            // console.log(newHBK, keydata)
            return await window.crypto.subtle.importKey("raw", newHBK, {name: "PBKDF2"}, false, ["deriveBits", "deriveKey"])
        }
        async function get_user_id(publicKey) {
            digest = new Uint8Array(await window.crypto.subtle.digest({ name: "SHA-256" }, encode.b64_to_bytes(publicKey))).slice(0,12)
            return encode.bytes_to_b64(digest)
        }
        let encode = {
            int_to_uint8: function int_to_uint8(value) {
                let bytes = new Uint8Array(4) // 32-bit short
                for(let i=0; i<4; i++) {
                    bytes[i] = (value >> i*8) & 0xff
                }
                return bytes
            },
            uint8_to_int: function uint8_to_int(bytes) {
                let value = 0
                for(let i=0; i<4; i++) {
                    value += bytes[i] << i*8
                }
                return value
            },
            bytes_to_hex: function bytes_to_hex(bytes) {
                let text = ""
                for(let i = 0; i<bytes.length; i++) {
                    text += bytes[i].toString(16).padStart(2, "0")
                }
                return text
            },
            hex_to_bytes: function hex_to_bytes(text) {
                let byteLength = text.length >> 1
                let bytes = new Uint8Array(byteLength)
                for(let i=0; i<byteLength; i++) bytes[i] = Number("0x"+text.substring(i*2, i*2+2))
                return bytes
            },

            base64Chars: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
            picker: function picker(n) {return encode.base64Chars.substring(n,n+1)},
            finder: function finder(x) {return x == "" ? -1 : encode.base64Chars.indexOf(x)},
            arrayBuffer_to_b64: function(arrayBuffer) {
                return encode.bytes_to_b64(new Uint8Array(arrayBuffer))
            },
            bytes_to_b64: function bytes_to_b64(bytes) {
                let text = ""
                let padding = bytes.length % 3
                for(let i = 0; i<bytes.length; i+=3) {
                    text += encode.picker((bytes[i] & 252) >> 2)
                    text += encode.picker(((bytes[i] & 3) << 4) + ((bytes[i+1] & 240) >> 4))
                    text += encode.picker(((bytes[i+1] & 15) << 2) + ((bytes[i+2] & 192) >> 6))
                    text += encode.picker(bytes[i+2] & 63)
                }
                if(padding != 0) text = text.substring(0,text.length-(1+2-padding))
                return text
            },
            b64_to_bytes: function b64_to_bytes(text) {
                text.replace("=", "")
                let bytes = new Uint8Array(3*text.length/4)
                let byteEnum = 0
                for(let i=0; i<text.length; i+=4) {
                    let values = [
                        encode.finder(text.substring(i,i+1)),
                        encode.finder(text.substring(i+1,i+2)),
                        encode.finder(text.substring(i+2,i+3)),
                        encode.finder(text.substring(i+3,i+4))
                    ]
                    // (111111 (xxxxxx00) + 110000 (000000xx))
                    bytes[byteEnum] = (values[0] << 2) + ((values[1] & 48) >> 4)
                    // (001111 (xxxx0000) + 111100 (0000xxxx))
                    bytes[byteEnum+1] = ((values[1] & 15) << 4) + ((values[2] & 60) >> 2)
                    // (000011 (xx000000) + 111111 (00xxxxxx)
                    bytes[byteEnum+2] = ((values[2] & 3) << 6) + (values[3])
                    byteEnum+=3
                }
                return bytes
            },
            int_to_b64: function int_to_b64(value) {
                let bytes = encode.int_to_uint8(value)
                return encode.bytes_to_b64(bytes)
            },
            b64_to_int: function b64_to_int(text) {
                let bytes = encode.b64_to_bytes(text)
                if(bytes.byteLength < 4) throw Error("SizeError: Value too large (more than 4 bytes)")
                return encode.uint8_to_int(bytes)
            }
        }

        async function globalDecryptFromJson(stringifiedMessageObject) {
            let messageObject = JSON.parse(stringifiedMessageObject)
            return await globalDecrypt(messageObject.data, messageObject.iv, messageObject.iters)
        }
        async function globalDecrypt(cipherString, iv, iters) {
            let globalEncryptionKey = await getKeyFromIters(globalsharedKey, globalHMACKey, globalSalt_xor, encode.b64_to_int(iters))
            return new TextDecoder().decode(new Uint8Array(await window.crypto.subtle.decrypt(
                { name: "AES-GCM", iv: encode.b64_to_bytes(iv) },
                globalEncryptionKey,
                encode.b64_to_bytes(cipherString)
            )).slice(checksumSize))
        }
        let getKeyFromIters = () => {}
        let globalsharedKey = null
        let globalMessageObject = null
        let globalSalt_xor = null
        let globaliv = null
        let globalHMACKey = null
        let globalws = null
        let ignoreId = 0
        let checksumSize = 16
        window.onload = async () => {
            document.getElementById("keys").innerText = localStorage.derivKeyPub + "\n" + await get_user_id(localStorage.derivKeyPub)
            document.getElementById("insertPubKey").addEventListener("click", async () => {
                ignoreId++
                document.getElementById("output").innerText = ""
                let passphrase = prompt("Password:")
                let uwkdf = await window.crypto.subtle.importKey("raw", new TextEncoder().encode(passphrase), { name: "PBKDF2" }, false, ["deriveKey"])
                let passwd = await window.crypto.subtle.deriveKey({ name: "PBKDF2", salt: mksalt(10000, 9203, 8008135), iterations: 1000, hash: "SHA-256" }, uwkdf, {name: "AES-GCM", length: 256}, true, ["encrypt", "decrypt"])
                console.log(passwd)
                if(localStorage.getItem("derivKey") == null){
                    // let signingKey = await generate_signing_key()
                    let derivKey = await generate_derivation_key()
                    let exportedDerivKey = new Uint8Array(await window.crypto.subtle.exportKey("pkcs8", derivKey.privateKey))
                    let iv = window.crypto.getRandomValues(new Uint8Array(16))
                    localStorage.setItem("derivIV", encode.bytes_to_b64(iv))
                    localStorage.setItem("derivKey", encode.arrayBuffer_to_b64(await window.crypto.subtle.encrypt({ name: "AES-GCM", iv }, passwd, exportedDerivKey)))
                    localStorage.setItem("derivKeyPub", encode.arrayBuffer_to_b64(await window.crypto.subtle.exportKey("spki", derivKey.publicKey)))
                    // localStorage.setItem("signKey", bytes_to_b64(new Uint8Array(await window.crypto.subtle.wrapKey("pkcs8", signingKey.privateKey, passwd, { name: "AES-KW" }))))
                    // localStorage.setItem("signKeyPub", bytes_to_b64(new Uint8Array(await window.crypto.subtle.exportKey("spki", signingKey.publicKey))))
                }
                let signingKey = {}
                let arrBuff = new Uint8Array(new ArrayBuffer(185))
                // arrBuff.set(b64_to_bytes(localStorage.getItem("signKey")))
                // signingKey.privateKey = await window.crypto.subtle.unwrapKey(
                //     "pkcs8",
                //     arrBuff,
                //     passwd,
                //     { "name": "AES-KW" },
                //     { "name": "Ed25519" },
                //     true,
                //     ["sign"],
                // )
                // arrBuff = new Uint8Array(new ArrayBuffer(44))
                // arrBuff.set(b64_to_bytes(localStorage.getItem("signKeyPub")))
                // signingKey.publicKey = await window.crypto.subtle.importKey(
                //     "spki",
                //     arrBuff,
                //     { "name": "Ed25519" },
                //     true,
                //     ["verify"]
                // )
                let derivKey = {}
                // arrBuff = new Uint8Array(new ArrayBuffer(56))
                // let derivAlgoParams = 
                // if(localStorage.getItem("usingECDH") == "true") { algoParams = { name: "ECDH", namedCurve: "P-384" }; arrBuff = new Uint8Array(new ArrayBuffer(185))}
                // else derivAlgoParams = { name: "X25519" }
                let iv = encode.b64_to_bytes(localStorage.getItem("derivIV"))
                arrBuff.set(new Uint8Array(await window.crypto.subtle.decrypt({name: "AES-GCM", iv}, passwd, encode.b64_to_bytes(localStorage.getItem("derivKey")))))
                console.log(arrBuff)
                derivKey.privateKey = await window.crypto.subtle.importKey(
                    "pkcs8",
                    arrBuff, // new ArrayBuffer(hex_to_bytes(localStorage.getItem("signKey"))),
                    { name: "ECDH", namedCurve: "P-384" },
                    true,
                    ["deriveKey", "deriveBits"],
                )
                arrBuff = new Uint8Array(new ArrayBuffer(120))
                // if(localStorage["usingECDH"] == "true") { arrBuff = new Uint8Array(new ArrayBuffer(120)) }
                arrBuff.set(encode.b64_to_bytes(localStorage.getItem("derivKeyPub")))
                derivKey.publicKey = await window.crypto.subtle.importKey(
                    "spki",
                    arrBuff,
                    { name: "ECDH", namedCurve: "P-384" },
                    true,
                    []
                )
                console.log(derivKey)
                let ext_pubkey = null
                let b64_ext_pubkey = null
                let key2 = {}
                let sharedKey = null
                let challengeComplete = false
                let decrypt = () => {}
                let ws = new WebSocket("ws://127.0.0.1:8000/ws?key="+localStorage.derivKeyPub)
                ws.onopen = async () => {
                    challengeComplete = false
                    ws.onmessage = async (e) => {
                        let data = JSON.parse(e.data)
                        console.log(data)
                        if(data["type"] == "challenge") {
                            b64_ext_pubkey = document.getElementById("outsidePublicKey").value
                            if(b64_ext_pubkey.length == 16) {
                                b64_ext_pubkey = data["onlineUsers"][b64_ext_pubkey]
                                console.log(b64_ext_pubkey)
                            }
                            ext_pubkey = encode.b64_to_bytes(b64_ext_pubkey)
                            key2.publicKey = await window.crypto.subtle.importKey(
                                "spki",
                                ext_pubkey,
                                { name: "ECDH", namedCurve: "P-384" },
                                true,
                                []
                            )
                            sharedKey = await derive_symmetric_key(derivKey.privateKey, key2.publicKey)
                            console.log("challenge")
                            console.log(data["p384key"])
                            let serverPubkey = await window.crypto.subtle.importKey("spki", encode.b64_to_bytes(data["p384key"]), { name: "ECDH", namedCurve: "P-384" }, false, [])
                            let serverSharedKey = await window.crypto.subtle.exportKey("raw", await derive_symmetric_key(derivKey.privateKey, serverPubkey))
                            let HMACKey = await window.crypto.subtle.importKey("raw", serverSharedKey, { name: "HMAC", hash: "SHA-512" }, false, ["sign"])
                            let digest = await window.crypto.subtle.sign({ name: "HMAC", hash: "SHA-512" }, HMACKey, encode.b64_to_bytes(data["randomBytesChallenge"]).slice(0,64))
                            console.log(encode.b64_to_bytes(data["randomBytesChallenge"]))
                            // let digest = await window.crypto.subtle.digest({ name: "SHA-256" }, encode.b64_to_bytes(data["randomBytesChallenge"]).slice(0,64))
                            console.log(encode.arrayBuffer_to_b64(digest))
                            ws.send(new Uint8Array(digest))
                            challengeComplete = true
                            document.getElementById("invisBtn").click()
                        }
                        else if(data["type"] == "recipientNotFound") {
                            console.log("Recipient is not online.")
                            decrypt(false, globalMessageObject)
                        }
                        else if(data["action"] == "msg"){
                            decrypt(false, e.data)
                        }
                        else { console.log(data) }
                    }
                }

                ws.onclose = (e) => {
                    ws = new WebSocket("ws://127.0.0.1:8000/ws?key="+localStorage.derivKeyPub)
                }
                globalws = ws
                document.getElementById("invisBtn").addEventListener("click", async () => {
                    console.log(encode.arrayBuffer_to_b64(await window.crypto.subtle.exportKey("raw", sharedKey)))
                    globalsharedKey = sharedKey
                    let hashedSKey = await window.crypto.subtle.digest({ name: "SHA-512" }, await window.crypto.subtle.exportKey("raw", sharedKey))
                    let xor_values = new Uint32Array(hashedSKey)
                    const salt_xor = xor_values[xor_values[0] & 63] ^ xor_values[xor_values[1] & 63] ^ xor_values[xor_values[62] & 63] ^ xor_values[xor_values[63] & 63]
                    globalSalt_xor = salt_xor
                    let keydf = await new_pbkdf(sharedKey, 0, salt_xor)
                    // let encryptionKey = await derive_new_key(keydf, 0, salt_xor)
                    let salt_xor_xor = mksalt(9000, salt_xor+91, salt_xor)
                    let keyData = new Uint8Array(256)
                    for(let i=0; i<512; i++) keyData[i&255] ^= mksalt(50+(salt_xor&0xff), 0x6837-i, salt_xor^salt_xor_xor[i%32])[i&15] & 0xff
                    let HMACKey = await window.crypto.subtle.importKey("raw", keyData, {name: "HMAC", hash: "SHA-512"}, true, ["sign"])
                    globalHMACKey = HMACKey
                    // console.log("HMACKey: ", new Uint8Array(await window.crypto.subtle.exportKey("raw", HMACKey)))
                    console.log(HMACKey)
                    let iters = 0
                    let listenerId = ignoreId
                    getKeyFromIters = async (sharedKey, HMACKey, salt_xor, iters) => {
                        let keydf = await new_pbkdf(sharedKey, iters, salt_xor, HMACKey)
                        let encryptionKey = await derive_new_key(keydf, iters, salt_xor)
                        return encryptionKey
                    }
                    document.getElementById("keys").innerText = localStorage.derivKeyPub + "\n" + await get_user_id(localStorage.derivKeyPub)
                    document.getElementById("submit").addEventListener("click", async () => {
                        if(listenerId != ignoreId) return
                        if(document.getElementById("inputBox").value == "") { console.log("Empty string"); return }
                        //! iv must be random
                        // let iv = await window.crypto.subtle.deriveBits({name: "PBKDF2", salt: mksalt(10, iters+(oldkdf[0]^oldkdf[2])), hash: "SHA-512", iterations: 1000}, keydf, 128)
                        let iters_gen = window.crypto.getRandomValues(new Uint32Array(4))
                        let iters = (iters_gen[0] ^ iters_gen[1] ^ iters_gen[3] ^ iters_gen[4])
                        let iv = await window.crypto.getRandomValues(new Uint8Array(16))
                        let keydf = await new_pbkdf(sharedKey, iters, salt_xor, HMACKey)
                        let encryptionKey = await derive_new_key(keydf, iters, salt_xor)
                        globaliv = iv
                        let stringToEncrypt = document.getElementById("inputBox").value
                        let encodedString = new TextEncoder().encode(stringToEncrypt)
                        // let checksum = new Uint8Array(await window.crypto.subtle.digest("SHA-512", encodedString)).slice(0,8)
                        let checksum = new Uint8Array(await window.crypto.subtle.sign({ name: "HMAC", hash: "SHA-512" }, HMACKey, encodedString)).slice(0,checksumSize)
                        let msgLength = encodedString.byteLength + checksum.byteLength
                        let message = new Uint8Array(msgLength)
                        message.set(checksum, 0)
                        message.set(encodedString, checksum.byteLength)
                        let cipherBytes = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv }, encryptionKey, message)
                        // let signature = new Uint8Array(await window.crypto.subtle.sign({name: "Ed25519"}, signingKey.privateKey, cipherBytes))
                        // console.log(signature)
                        // let verification = await window.crypto.subtle.verify({name: "Ed25519"}, signingKey.publicKey, signature, cipherBytes)
                        // console.log(verification)
                        let messageObject = {
                            "action": "msg",
                            "data": encode.arrayBuffer_to_b64(cipherBytes),
                            "iv": encode.bytes_to_b64(iv),
                            // "signature": bytes_to_b64(signature),
                            "iters": encode.int_to_b64(iters),
                            "to": await get_user_id(b64_ext_pubkey),
                            "from": await get_user_id(localStorage.derivKeyPub)
                        }
                        globalMessageObject = messageObject
                        console.log(messageObject)
                        ws.send(JSON.stringify(messageObject))
                        // document.getElementById("output").innerText += JSON.stringify(messageObject)+"\n"
                        document.getElementById("inputBox").value = ""
                        iters++
                        // document.getElementById("output").innerText = btoa(new TextDecoder("utf-8").decode(cipherBytes))
                    })
                    decrypt = async (textbox, obj) => {
                        let messageObject = null
                        if(textbox) {
                            if(document.getElementById("decryptBox").value == "") return
                            messageObject = JSON.parse(document.getElementById("decryptBox").value)
                        }
                        else {
                            // console.log(obj, typeof obj)
                            if(typeof obj == "object") messageObject = obj
                            else messageObject = JSON.parse(obj)
                        }
                        let decryptionKey = await getKeyFromIters(sharedKey, HMACKey, salt_xor, encode.b64_to_int(messageObject.iters))
                        let decryptedBytes = new Uint8Array(
                            await window.crypto.subtle.decrypt(
                                { name: "AES-GCM", iv: encode.b64_to_bytes(messageObject.iv) },
                                decryptionKey,
                                encode.b64_to_bytes(messageObject.data)
                            )
                        )
                        let checksum = new Uint8Array(await window.crypto.subtle.sign(
                            { name: "HMAC", hash: "SHA-512" },
                            HMACKey,
                            decryptedBytes.slice(checksumSize)
                        )).slice(0,checksumSize)
                        if(checksum.values == decryptedBytes.slice(0,checksumSize).values)
                            document.getElementById("decryptOutput").innerText = new TextDecoder().decode(decryptedBytes.slice(checksumSize))
                    }
                    document.getElementById("decrypt").addEventListener("click", async () => await decrypt(true))
                })
            })
        }
    </script>
    <button id="invisBtn" style="visibility: hidden; position: absolute;"></button>
    <input type="text" style="width: 500px" id="outsidePublicKey" placeholder="Public key to use">
    <button id="insertPubKey">Use</button>
    <br>
    <textarea id="inputBox" placeholder="Message to encrypt"></textarea>
    <button id="submit">submit</button>
    <br>
    <textarea id="decryptBox" placeholder="Encrypted message as stringified JSON"></textarea>
    <button id="decrypt">Decrypt</button>
    <pre id="decryptOutput"></pre>
    <pre id="output"></pre>
    <pre id="keys"></pre>
</head>